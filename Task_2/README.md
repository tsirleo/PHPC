# Практическое задание «Параллельная сортировка Бэтчера» 

## Описание условия  

Задан массив элементов типа double, при этом считаем, что количество элементов массива достаточно большое, чтобы поместиться в память одного процесса. 

**На входе:** на каждом процессе одинаковое количество элементов массива. (Если на некоторых процессах элементов массива меньше, чем во всех остальных, тогда необходимо ввести фиктивные элементы, например, со значением DBL_MAX или - DBL_MAX в зависимости от направления сортировки.) 

**Цель:** разработать и реализовать алгоритм, обеспечивающий параллельную сортировку методом Бэтчера элементов массива в соответствии с заданным направлением. (по возрастанию или по убыванию) Следует реализовать сортировку на каждом отдельном процессе и сеть сортировки Бэтчера. 

**На выходе:** на каждом процессе одинаковое количество элементов массива. Все элементы массива, принадлежащие одному процессу отсортированы по возрастанию (убыванию), Каждый элемент массива одного процесса должен быть меньше (больше) по сравнению с элементами массива любого процесса с большим рангом, за исключением фиктивных элементов. 

**Требования к программе:** 

1. Программа может быть гибридной: одновременно использовать технологию MPI, для обеспечения взаимодействия вычислительных узлов, и одну из двух технологий Posix threads или OpenMP, для взаимодействия процессов, запущенных на ядрах процессоров 
2. Программа должна демонстрировать эффективность не менее 50% от максимально возможной, на числе вычислительных ядер, не менее 48 (Запуск программы на параллельном кластере в этом задании обязательно!) 

## Описание метода решения 

Для составления расписания сортировки использовался алгоритм и код из [первого практического задания](https://github.com/tsirleo/PHPC/tree/main/Task_1).  

**Функции из первого практического задания:** 

***BatcherSort*** – функция рекурсивного делит массив на два подмассива из **p** и **m** элементов соответственно, после чего вызывает функцию слияния BatcherMerge для этих подмассивов. В реализации отсутствует работа с массивом, оперирование происходит только с индексами условного массива элементов. 

***BatcherMerge*** – функция рекурсивного слияния двух групп линий. В сети нечетно- четного слияния отдельно объединяются элементы массивов с нечетными номерами и отдельно с четными, после чего с помощью заключительной группы компараторов обрабатываются пары соседних элементов. Данные пары записываются в массив компараторов comparators для дальнейшего использования. В реализации опять же отсутствует работа с массивов, оперирование идет только с индексами, и происходит заполнение массива сравниваемых пар номеров строк, соединяемых i-м компаратором сравнения перестановки. 

**Дополнительно реализованы следующие функции:** 

***Comparator*** – функция отвечающая за коммуникацию процессов и слияния, т.е. обмен элементов локальных данных и перераспределение их по возрастанию, так, чтобы в итоге каждый элемент массива одного процесса был меньше по сравнению с элементами массива любого процесса с большим рангом. Функция работает согласно построенному расписанию компараторов. Данная функция написана в соответствии с псевдокодом представленным на слайдах 74–75 [лекции](https://lira.imamod.ru/msu202209/L05_20221017_YakobovskiyMV.pdf). 

Для формирования массива, содержащего меньшие(большие) элементы использовался алгоритм из книги М.В. Якобовского “Введение в параллельные методы решения задач” стр. 152. 

***generateRandomDouble*** – генерирует случайные вещественные числа, используется для инициализации массива случайными данными. 

***checkSorted*** – функция для проверки, что полученный массив отсортирован. 

Главная функция программы ***main*** выполняет следующие шаги: 

- Получение из аргументов командной строки размера вектора. 
- Инициализация MPI и определение числа процессов и рангов. 
- Генерация локальных данных в каждом процессе. 
- Составление расписания сети сортировки Бэтчера. 
- Сортировка локальных кусков массива c использованием функции std::sort из библиотеки <algorithm>. 
- Выполнение параллельного слияния элементов. 
- Сбор итоговых данных на процессе с рангом 0. 
- Проверка, что массив отсортирован и вывод результата работы по времени. 

Для компиляции программы и постановки в очередь на Polus написан Makefile. 

- Компиляция: 
    ```shell
    make compile 
    ```
- Постановка в очередь на polus: 
    ```shell
    make run\_polus
    ```
- Запуск со значением размера массива по умолчанию (100 тыс.): 
    ```shell
    make run
    ```
- Запуск с явным указанием размера массива: 
    ```shell
    mpirun -np P ./pbsort N
    ```
    , где *N* – количество элементов конечного массива, *P* – количество процессов. 
